"""
    Provides :class:`SlugField`, which allows one to form a slug field
    which fetches its data automatically from the related title field, whilst
    ensuring its uniqueness.

    The most straightforward example would be::

        from fluxbase.fields.slugfield import SlugField

        class Article(models.Model):
            title   = models.CharField(max_length = 255)
            content = models.TextField()
            slug    = SlugField(title = 'title')

    When one now adds a new `Article`, the value of slug is automatically
    inferred from that of `title`. In case of a duplicate, a unique name is
    created by counting the amount of duplicates.

    A more complex example::

        class Franchise(models.Model):
            name        = models.CharField(max_length = 100)

        class Store(models.Model):
            name        = models.CharField(max_length = 100)
            franchise   = models.ForeignKey(Franchise)
            slug        = SlugField(title = 'name', unique_with = ('franchise'))

    This makes sure that for each instance of `Store`, the pair franchise-slug
    is unique. 
"""


from django.db import models
from django.template.defaultfilters import slugify                        

class SlugField(models.SlugField):
    """Auto-generated slug field, related to a title. This field is intended as
    an automatically generated slug, related to a specific field which should be
    near-unique. Initialize with title which is used to derive the slug and 
    unique-with, which is a list of fields whith which the slug should be unique."""

    def __init__(self, title, unique_with = None, reserved_words=[], **kwargs):
        """Build a new SlugField, autogenerated out of field title, such that
        it is unique with the fields in unique-with. This unique-with information
        is used to speed up queries, it can be a list of fields or a single field."""

        if isinstance(title, unicode) or isinstance(title, str):
            self.slugSeed = [title]
        elif isinstance(title, list):
            self.slugSeed = title
                    
        # Store the appropriate uniqueness fields
        if isinstance(unique_with, unicode) or isinstance(unique_with, str):
            self.unique_with = [unique_with]
        elif isinstance(unique_with, list):
            self.unique_with = unique_with
        elif unique_with is None:
            self.unique_with = []
        else:
            raise UniqueWithWrongType(unique_with)
        
        #Set some of the defaults. Slugs can never be updated
        kwargs['editable'] = False
        kwargs['null' ] = False
        
        self.reserved_words = reserved_words

        super(SlugField, self).__init__(**kwargs)

    def getPreSlugged(self, instance):
        preSlugValues = []
        for title in self.slugSeed:
            preSlugValues.append(str(getattr(instance, title)))
        return '-'.join(preSlugValues)
                
    def pre_save(self, instance, add):
        if not add:
            # old instance, slugs don't change.
            return getattr(instance, self.attname)
        
        # This is a new instance, compute the slug
        preSlugged = self.getPreSlugged(instance)
        slugged = slugify(preSlugged).replace('_', '-')[:self.max_length-5]
        
        # Update the slug appropriately
        slugPostfix = ''
        i = 0
        while True:
            _slugged = '%s%s' % (slugged, slugPostfix)
            
            lal = self.count_look_a_likes(_slugged, instance)
            if lal > 0:
                i = i + 1 if lal<i else lal
                slugPostfix = i
            else: # No matches
                break

        slugged = _slugged
        
        setattr(instance, self.attname, slugged)

        return slugged

    def count_look_a_likes(self, slugged, instance):
        # Build a filter, use given uniqueness fields to reduce the amount of
        # rows on which to do a regexp.
        filterDict = dict( 
                (unique_part, getattr(instance, unique_part))
            for  unique_part in self.unique_with)


        filterDict['%s__regex' % self.attname] = '^%s[0-9]*$' % slugged
        
        # Count the number of rows that match this slug
        look_a_likes = instance.__class__.objects.\
            filter(**filterDict).\
            values_list('slug', flat = True).\
            count()

        if slugged in self.reserved_words:
            look_a_likes += 1

        return look_a_likes

    class UniqueWithWrongType(Exception):
        def __init__(self, unique_with):
            self.unique_with = unique_with
    
        def __unicode__(self):
            return '%s is neither a (unicode)string, nor a list, nor None, hence not suited for uniqueness data' % self.unique_with
            
# Ensure that south knows what to do
HAS_SOUTH = True
try:
    from south.modelsinspector import add_introspection_rules
except ImportError as exp:
    HAS_SOUTH = False

if HAS_SOUTH:
    add_introspection_rules([
        (
            [SlugField], 
            [],         
            {      
                    'title'       : ['slugSeed', {}]
                ,   'unique_with' : ['unique_with', { 'default' : None}]
            },
        ),
    ], [r'^fluxbase\.fields\.slugfield\.SlugField$'])
